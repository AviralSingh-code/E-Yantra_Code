#!/usr/bin/env python3


import cv2
import numpy as np
import roslib
import sys
import rospy
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError
import tf2_ros
import geometry_msgs.msg
import tf_conversions



tomatoColor = [[0, 37, 117, 0, 250, 255]]
imgContour = None
depth_image = np.empty((480,640),float)
midX = 0
midY = 0



def callback_depth(data_depth):

    global depth_image

    try:
        bridgeDepth = CvBridge()
        depth_image = bridgeDepth.imgmsg_to_cv2(data_depth, "32FC1")
    except CvBridgeError as e:
        print(e)





def getContours(img):
    global imgContour
    global midX
    global midY
    global depth_image
    depth = 0
    cx = 320.5
    cy = 240.5
    fx = 554.387
    fy = 554.387
    contours, hierarchy = cv2.findContours(img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    x, y, w, h = 0, 0, 0, 0
    midX = 0
    midY = 0
    counter = 1
    for cnt in contours:
        area = cv2.contourArea(cnt)
        # print(area)    -----------> for getting the area of the area of interest
        if area > 100:                      #------> thresholding parameter
            peri = cv2.arcLength(cnt, True)

            approx = cv2.approxPolyDP(cnt, 0.02 * peri, True)

            x, y, w, h = cv2.boundingRect(approx)

            cv2.circle(imgContour, (x+(w // 2), y+(h // 2)), max(h // 2, w // 2), (255, 0, 0), 1)
            cv2.circle(imgContour, (x+(w // 2), y+(h // 2)), 1, (255, 0, 0), -1)
            midX = x + w // 2
            midY = y + h // 2


            if midX != 0 and midY != 0 and midX <= 640 and midY <= 480:
                depth = depth_image[midY][midX]

            X = depth*((midX-cx)/fx)
            Y = depth*((midY-cy)/fy)
            Z = depth


            br = tf2_ros.TransformBroadcaster()
            t = geometry_msgs.msg.TransformStamped()
            t.header.stamp = rospy.Time.now()
            t.header.frame_id = "camera_link2"
            t.child_frame_id = "obj"+str(counter)

            cv2.putText(imgContour, t.child_frame_id,
            (midX, midY), cv2.FONT_HERSHEY_SIMPLEX,
            0.5, (0, 255, 0), 2)


            t.transform.translation.x = Z
            t.transform.translation.y = -X
            t.transform.translation.z = Y

            q = tf_conversions.transformations.quaternion_from_euler(0, 0, 0)
            t.transform.rotation.x = q[0]
            t.transform.rotation.y = q[1]
            t.transform.rotation.z = q[2]
            t.transform.rotation.w = q[3]

            br.sendTransform(t)

            counter = counter+1

    cv2.imshow("Result",imgContour)
    cv2.waitKey(1)

    return x + w // 2, y + h // 2  # for mid of the box



def callback(data):
    global imgContour
    try:
        bridge = CvBridge()
        frame = bridge.imgmsg_to_cv2(data, "bgr8")
        imgContour = frame.copy()
        imgHSV = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        x, y = 0, 0
        for color in tomatoColor:
            lower = np.array(color[0:3])
            upper = np.array(color[3:6])
            mask = cv2.inRange(imgHSV, lower, upper)
            x, y = getContours(mask)   
    except CvBridgeError as e:
        print(e)



def main(args):
    rospy.init_node('object_detection', anonymous=True)
    depth_sub = rospy.Subscriber("/camera/depth/image_raw2", Image, callback_depth)  
    image_sub = rospy.Subscriber("/camera/color/image_raw2", Image, callback)  
    try:
        rospy.spin()
    except KeyboardInterrupt:
        print("Shutting down")
    cv2.destroyAllWindows()

if __name__ == '__main__':
    main(sys.argv)
        